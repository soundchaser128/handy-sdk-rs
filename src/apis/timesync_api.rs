/*
 * Handy API v2.0.0
 *
 * API to interact with the 'TheHandy'. <p> <b>IMPORTANT</b>: This API is compatible with devices running firmware version 3 (v3) only. See note below on how to deal with firmware version 2 (v2) devices with this API. <p> <h3>Join the community</h3> Send us a mail or add us on discord for a more technical chat - **Handy#8756**<br> Follow us on Reddit for updates and announcements: https://www.reddit.com/r/theHandy/ <p> <h3>Server selection</h3> When using the API make sure you connect to the server environment that the device you are trying to interact with is connected to.<br> For most users this will be the production environment API server: <b>https://www.handyfeeling.com/api/handy/v2</b><br> If you have been given special access to firmware that connects to the staging environment, you should use the staging environment API server: <b>https://staging.handyfeeling.com/api/handy/v2</b><br> <p> <h3>Handling firmware v2 devices</h3> Users with firmware v2 devices are required to update their device to firmware v3 before the device can be fully used with this API.<br> To ease this process, two of the endpoints in this API can be used with firmware v2 devices:<br> <ul> <li><code>/connected</code> - Check online status of a device.</li> <li><code>/info</code> - Get general information about the device.</li> </ul> All other endpoints will always return a 'Machine not connected' error if you try to use them with a firmware v2 device.<br><br> For v2 devices it's important to handle the fwStatus returned from the <code>/info</code> endpoint properly.<br> v2 devices will always have fwStatus = UPDATE_REQUIRED(2). See <code>/info</code> documentation for more details.<br><br> When using the API with a device, you should always start by verifying that the device have a firmware that is compatible with the API you are using in your service.<br> An example flow could look like this: <ol> <li>Check if device is conncted with <code>/connected</code></li> <li>Check device firmware status with <code>/info</code></li> <li>If a firmware update is required, forward the user to <a href=\"https://www.handfyfeeling.com\">https://www.handfyfeeling.com</a> so they can easily update the device firmware.</li> <li>Continue your service when the firmware status returned in <code>/info</code> is UP_TO_DATE(0).</li> </ol> <p> <h3>Mode specific operations</h3> Operations in <b>BASE</b>, <b>SLIDE</b>, <b>TIMESYNC</b> and <b>HSTP</b> are mode independent and available at any time.<br> Other operations are only available in a specific mode (eg. <b>HAMP</b>, <b>HDSP</b>, <b>HSSP</b>).<br> To access these operations, the device have to first be put in the specific mode (see <code>/mode</code>).<br> If you execute an operation not available in the current mode of the device, you will receive a 'No such method' error response. <!--See live samples of use cases here: 'https://www.handyfeeling.com/api/handy/v2/demo/ -->
 *
 * The version of the OpenAPI document: 2.0.0-beta-3
 * Contact: lars@sweettech.no
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;
use crate::models;

/// struct for typed errors of method [`get_server_time`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetServerTimeError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// Provides the server time that you must use when calculating the client-server-offset (<i>cs_offset</i>), which is used when calculating a client-side-estimated-server-time (<i>Tcest</i>).<br><br> <h2>Client-server-offset</h2> The client-server-offset (<i>cs_offset</i>) can be calculated the following way: <br> <ol> <li>Collect X server time (<i>Ts</i>) samples using this endpoint. A higher number of samples will results in longer estimation time but a more accurate result. A good sample size is 30 (X = 30).</li> <li>Track the round-trip-delay (<i>RTD</i>) for each sample by recording the request send time (<i>Tsend</i>) and response received time (<i>Treceive</i>). Calculate <i>RTD = Treceive â€“ Tsend</i>.</li> <li>Calculate the estimated server time when the response is received (<i>Ts_est</i>) by adding half the RTD time to the received server time value (<i>Ts</i>). <i>Ts_est  = Ts + RTD/2</i>.</li> <li>Calculate the offset between estimated server time (<i>Ts_est</i>) and client time (<i>Tc</i>). Upon receive <i>Tc == Treceive</i> => <i>offset = Ts_est  - Treceive</i>.</li> <li>Add the offset to the aggregated offset value (<i>offset_agg</i>).  <i>offset_agg = offset_agg + offset</i>.</li> <li>When all samples have been received calculate the average offset (<i>cs_offset</i>) by dividing aggregated offset (<i>offset_agg</i>) values by the number of samples (X). <i>cs_offset = offset_agg / X</i></li> </ol> The process above gives you a good estimate of the client-server-offset (<i>cs_offset</i>).<br><br> Normally you calculate the <i>cs_offset</i> once, and use it whenever you need to calculate client-side-estimated-server-time (<i>Tcest</i>).<br> However, if the synchronization between device and the service (eg. video/script synchronization) is off (maybe due to changing network topology, clock drift, bad initial calculation, etc.), it might help to re-calculate the <i>cs_offset</i>. <h2>Client-side-estimated-server-time</h2> The client-side-estimated-server-time (<i>Tcest</i>) value is required in some of the API endpoints (eg. /hssp/play).<br><br> The <i>Tcest</i> is calculated the following way:<br><br> &nbsp;&nbsp;&nbsp;<i>Tcest = Tc + cs_offset</i><br><br> where <i>Tc</i> is the current client time and <i>cs_offset</i> is the client-server-offset.
pub async fn get_server_time(
    configuration: &configuration::Configuration,
) -> Result<models::ServerTimeResponse, Error<GetServerTimeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/servertime", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetServerTimeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
